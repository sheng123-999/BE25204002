% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/decode_schedule.R
\name{decode_schedule}
\alias{decode_schedule}
\title{Decode Particle and Calculate Multi-Objective Fitness (4PL Logistics Scheduling Optimization)}
\usage{
decode_schedule(
  particle,
  tasks,
  self_resource,
  outsourced_resource,
  resource_windows,
  resource_joint_cost,
  resource_mapping
)
}
\arguments{
\item{particle}{List, a single particle object containing attributes such as position (subtask-resource mapping) and velocity.}

\item{tasks}{List, collection of logistics tasks, each task includes:
\itemize{
\item priority: Task priority (1-3, 3 is the highest);
\item due_date: Task deadline;
\item delay_penalty: Delay penalty coefficient;
\item activities: List of subtasks, each subtask includes name and execution time/cost/demand of available resources;
\item relationships: Dependencies between subtasks (0 for serial, 1 for parallel).
}}

\item{self_resource}{List, information of self-owned resources, each resource includes a 'capacity' attribute.}

\item{outsourced_resource}{List, information of outsourced resources, each resource includes 'capacity' and 'cost_ratio' attributes.}

\item{resource_windows}{List, resource time windows, each resource corresponds to a binary vector (start time, end time).}

\item{resource_joint_cost}{List, resource switching costs, with keys as "ResourceA,ResourceB" and values as binary vectors (switching time, switching cost).}

\item{resource_mapping}{List, mapping from self-owned resources to outsourced resources (e.g., M1 = "O1").}
}
\value{
List containing:
\itemize{
\item fitness: Numeric vector (named) of length 6, with names:
"total_cost", "total_time", "util_variance", "total_direct_cost", "total_connection_cost", "total_delay_penalty";
\item schedule: List, mapping from task names to subtask details (each subtask includes start, end, resource, cost, demand, outsourced_amount, etc.).
}
}
\description{
For the multi-objective resource scheduling problem of Fourth-Party Logistics (4PL), this function decodes the particle's position (resource allocation scheme),
calculates a fitness vector of 6 objectives including total cost, total completion time, resource load variance, direct cost, connection cost, and delay penalty,
while considering constraints such as task priority, resource time windows, dependencies, and switching costs.
}
\details{
This function is the core decoding function for multi-objective optimization of 4PL logistics scheduling,
implementing the parsing of particle positions and the calculation of multi-objective fitness.
It considers key factors in actual logistics scenarios such as task dependencies, resource conflicts, and priority constraints.
A smaller fitness vector indicates a better scheduling scheme.
}
\examples{
# Build example data
resource_mapping <- list(M1 = "O1", M2 = "O2")
tasks <- list(
  task1 = list(
    priority = 2,
    due_date = 10,
    delay_penalty = 5,
    activities = list(
      list("subtask1_1", list(M1 = c(2.0, 10.0, 2), O1 = c(1.0, 20.0, 2))),
      list("subtask1_2", list(M2 = c(3.0, 15.0, 3), O2 = c(2.0, 25.0, 3)))
    ),
    relationships = c(0)
  )
)
self_resource <- list(M1 = list(capacity = 4), M2 = list(capacity = 5))
outsourced_resource <- list(
  O1 = list(capacity = 10, cost_ratio = 1.2),
  O2 = list(capacity = 10, cost_ratio = 1.2)
)
resource_windows <- list(M1 = c(0.0, 20.0), M2 = c(0.0, 20.0), O1 = c(0.0, 20.0), O2 = c(0.0, 20.0))
resource_joint_cost <- list("M1,M1" = c(0.0, 0.0), "M1,O1" = c(1.0, 5.0))

# Mock initialize_particles function (for example independence)
initialize_particles <- function(pop_size, tasks, resource_mapping) {
  subtask_names <- unlist(lapply(tasks, function(x) lapply(x$activities, `[[`, 1)))
  lapply(1:pop_size, function(i) {
    list(
      position = setNames(sample(c(names(self_resource), names(outsourced_resource)),
                                length(subtask_names), replace = TRUE),
                         subtask_names),
      velocity = NULL
    )
  })
}

# Initialize particles
particles <- initialize_particles(pop_size = 1, tasks = tasks, resource_mapping = resource_mapping)

# Decode particle and calculate fitness
result <- decode_schedule(
  particle = particles[[1]],
  tasks = tasks,
  self_resource = self_resource,
  outsourced_resource = outsourced_resource,
  resource_windows = resource_windows,
  resource_joint_cost = resource_joint_cost,
  resource_mapping = resource_mapping
)
print(result$fitness) # Now has named columns
print(result$schedule)

}
