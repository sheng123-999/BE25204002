% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/calculate_crowding_distance.R
\name{calculate_crowding_distance}
\alias{calculate_crowding_distance}
\title{计算前沿的拥挤距离}
\usage{
calculate_crowding_distance(front)
}
\arguments{
\item{front}{列表，前沿粒子的子列表。每个子列表必须包含\code{fitness}元素（数值向量，至少3个元素，
分别对应cost、time、variance）。}
}
\value{
列表，与输入结构一致，但每个粒子子列表新增\code{crowding_distance}字段，存储计算得到的拥挤距离。
}
\description{
该函数针对多目标优化中的前沿粒子列表，计算每个粒子的拥挤距离（Crowding Distance），
用于衡量粒子在前沿中的分散程度。计算时基于前3个目标（cost、time、variance，对应fitness向量的1、2、3索引）进行排序，
边界粒子的拥挤距离设为无穷大（Inf），内部粒子的距离为相邻粒子在各目标上的差值归一化之和。
}
\examples{
# 示例1：常规场景（5个粒子的前沿）
# 构造测试前沿粒子列表
set.seed(123) # 设定随机种子保证可复现
front <- list(
  list(fitness = c(2.5, 5.2, 1.8)),
  list(fitness = c(1.2, 7.1, 2.3)),
  list(fitness = c(3.7, 4.0, 1.5)),
  list(fitness = c(0.8, 8.5, 2.9)),
  list(fitness = c(4.1, 3.5, 1.2))
)

# 计算拥挤距离
front_with_cd <- calculate_crowding_distance(front)

# 查看每个粒子的拥挤距离
sapply(front_with_cd, function(x) x$crowding_distance)

# 示例2：边界场景1（前沿只有1个粒子）
front_single <- list(list(fitness = c(1.0, 2.0, 3.0)))
front_single_cd <- calculate_crowding_distance(front_single)
front_single_cd[[1]]$crowding_distance # 结果为0（因无相邻粒子）

# 示例3：边界场景2（前沿只有2个粒子）
front_two <- list(
  list(fitness = c(1.0, 2.0, 3.0)),
  list(fitness = c(4.0, 5.0, 6.0))
)
front_two_cd <- calculate_crowding_distance(front_two)
sapply(front_two_cd, function(x) x$crowding_distance) # 两个粒子均为Inf

}
