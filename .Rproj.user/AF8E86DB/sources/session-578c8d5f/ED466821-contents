---
title: "BE25204002: 多目标任务调度优化函数用法"
author: "Sheng zhoushan"
date: "2025-12-19"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{BE25204002: 多目标任务调度优化函数用法}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
```{r load-package, include=FALSE}
library(BE25204002)
```
```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 8,
  fig.height = 5
)
set.seed(123)
```
### 一、研究背景与方法概述
#### 1.1 研究背景
第四方物流（4PL）作为供应链集成者，需要协调自有资源（以 M 开头，如 M1、M2）和外包资源（以 O 开头，如 O1、O2），对多个订单拆解后的子任务进行多目标调度。该问题属于典型的 NP-hard 多目标优化问题，主要特征包括：
多目标：同时最小化总成本（直接成本 + 连接成本 + 延迟惩罚）、总完成时间、资源利用率方差。
复杂约束：任务优先级、资源时间窗口、子任务依赖关系、资源容量限制、资源切换成本、外包成本等。
计算需求：大规模场景下需要高效算法，核心支配判断通过 Rcpp 实现以提升性能。

本 vignette 介绍 BE25204002 包中实现的多目标粒子群优化算法（Multi-Objective Particle Swarm Optimization, MOPSO）， 重点说明各核心函数的用途、输入输出以及完整的使用流程。

该实现面向 多目标最小化问题，并结合：

非支配排序（Pareto ranking）

拥挤度距离（Crowding Distance）

外部精英档案（External Archive）

用于多目标任务调度与资源配置问题。

#### 1.2 包主要函数及作用
(1)initialize_particles()根据任务优先级初始化粒子群（资源分配方案）

(2)decode_schedule()将粒子解码为调度方案并计算 6 维适应度向量及详细schedule

(3)update_particles()粒子速度与位置更新（PSO 进化核心）

(4)dominates()（Rcpp）判断一个解是否支配另一个解

(5)calculate_crowding_distance()计算拥挤距离，用于存档多样性维护

(6)manage_archive()存档大小控制（拥挤距离截断）

(7)mopsso()主算法：完整多目标粒子群优化流程

(8)plot_gantt_chart()绘制调度甘特图（支持外包量标注）

### 二、代码运行

示例数据存放在包根目录的 data/ 下，可通过 load() 加载：
```{r, include=TRUE}
load("../data/test_data.RData")
```
加载后，环境中应包含以下对象：

tasks

self_resource

outsourced_resource

resource_windows

resource_joint_cost

resource_mapping

### 三、核心函数介绍

#### 3.1 dominates()

功能

判断解 a 是否在多目标最小化意义下 支配 解 b。

支配定义：

对所有目标：a[i] <= b[i]

至少存在一个目标：a[i] < b[i]

用法
```{r, include=TRUE}
a <- c(10, 5)
b <- c(12, 5)
dominates(a, b)
```
说明

若 C++ 版本 dominates_cpp()可用，则自动调用以提升性能，否则退回纯 R 实现

#### 3.2 non_dominated_sort()
功能

对粒子群进行非支配排序，返回每个粒子的 Pareto 等级（rank）。

rank = 1 表示第一前沿（最优）

用法
```{r, include=TRUE}
# particles 是粒子列表
particles <- list(
  list(fitness = c(10, 5)),
  list(fitness = c(12, 6)),
  list(fitness = c(9,  7))
)

ranks <- non_dominated_sort(particles)
ranks
```

#### 3.3 non_dominated_sort_fronts()
功能

基于非支配排序结果，返回 Pareto 前沿列表， 结构与 Python / NSGA-II 实现一致。

用法
```{r, include=TRUE}
# 构造一个最小粒子群（仅包含 fitness）
particles <- list(
  list(fitness = c(10, 5)),  # 解 1
  list(fitness = c(12, 6)),  # 解 2（被解1支配）
  list(fitness = c(9,  7)),  # 解 3（与解1互不支配）
  list(fitness = c(11, 4))   # 解 4（与解1互不支配）
)

# 非支配排序，得到 Pareto 前沿
fronts <- non_dominated_sort_fronts(particles)

# 前沿数量
length(fronts)

# 第一 Pareto 前沿上的解数量
length(fronts[[1]])

# 查看第一前沿中各解的 fitness
lapply(fronts[[1]], function(p) p$fitness)

```

#### 3.4 calculate_crowding_distance()
功能

计算同一 Pareto 前沿内粒子的 拥挤度距离， 用于保持解的多样性。

用法
```{r, include=TRUE}
# 构造一个至少包含 3 个解的 Pareto 前沿
front <- list(
  list(fitness = c(10, 5)),
  list(fitness = c(9,  7)),
  list(fitness = c(11, 4)),
  list(fitness = c(8,  6))
)

# 计算拥挤度距离
cd <- calculate_crowding_distance(front)

cd

```



#### 3.6 update_particles()
功能

执行一次 PSO 粒子更新，包括：

速度更新

位置更新

个体最优（pbest）更新

与外部档案的比较



#### 3.7 manage_archive()
功能

维护外部 Pareto 精英档案：

合并新解

非支配筛选

基于拥挤度的容量控制



#### 3.8 mopsso()
功能

MOPSO 主算法入口，完整执行多目标粒子群优化流程。

用法
```{r, eval = FALSE}
pareto_front <- mopsso(
  tasks = tasks,
  self_resource = self_resource,
  outsourced_resource = outsourced_resource,
  resource_windows = resource_windows,
  resource_joint_cost = resource_joint_cost,
  resource_mapping = resource_mapping,
  pop_size = 100,
  max_gen = 200,
  max_archive_size = 50
)
```
返回值

pareto_front：Pareto 最优解列表

#### 3.9 plot_gantt_chart()
功能

将某一 Pareto 解对应的调度方案绘制为甘特图。

用法
```{r, eval = FALSE}
plot_gantt_chart(
  schedule = pareto_front[[1]]$schedule,
  title = "Pareto 解 1",
  filename = "gantt_solution_1.png"
)
```

#### 总结

本 vignette 系统性展示了 BE25204002 包中 MOPSO 算法的：核心思想、使用流程

该实现适用于多目标任务调度与资源优化问题，也可作为进一步算法扩展（如 Rcpp加速、约束处理）的基础。